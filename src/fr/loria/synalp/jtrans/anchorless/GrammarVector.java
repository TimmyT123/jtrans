package fr.loria.synalp.jtrans.anchorless;

import edu.cmu.sphinx.frontend.*;
import edu.cmu.sphinx.frontend.util.AudioFileDataSource;
import edu.cmu.sphinx.linguist.acoustic.*;
import edu.cmu.sphinx.linguist.acoustic.tiedstate.TiedStateAcousticModel;
import edu.cmu.sphinx.linguist.language.grammar.*;
import edu.cmu.sphinx.util.LogMath;
import edu.cmu.sphinx.util.props.ConfigurationManager;
import fr.loria.synalp.jtrans.speechreco.s4.*;
import fr.loria.synalp.jtrans.utils.StdoutProgressDisplay;
import fr.loria.synalp.jtrans.utils.TimeConverter;

import java.io.*;
import java.net.MalformedURLException;
import java.util.*;

/**
 * Sweeping grammar vector for the experimental anchorless algorithm.
 */
public class GrammarVector {

	/**
	 * If this value ever has to exceed 255 (overkill!), be sure to change
	 * the type of the nTrans array.
	 */
	public static final int MAX_TRANSITIONS = 10;

	/** All HMM states in the grammar.
	 * TODO: speed up scoring with a set of unique states */
	private HMMState[] states;

	/** Number of transitions for each state */
	private byte[] nTrans;

	/** Transition matrix: successor IDs */
	private int[][] succ;

	/** Transition matrix: probabilities */
	private float[][] prob;

	/** Total number of non-empty phones contained in the grammar. */
	private final int nPhones;

	/** Total number of HMM states in the grammar. */
	private final int nStates;

	/**
	 * Counts undiscovered phones in a Sphinx4 grammar by traversing the grammar
	 * graph recursively. Empty nodes are not accounted for.
	 * @param node node of the graph to visit
	 * @param seen discovered nodes (won't be visited again)
	 */
	private static int countUnseenPhones(GrammarNode node, Set<GrammarNode> seen) {
		if (seen.contains(node))
			return 0;
		seen.add(node);
		int count = node.isEmpty()? 0: 1;
		for (GrammarArc arc: node.getSuccessors())
			count += countUnseenPhones(arc.getGrammarNode(), seen);
		return count;
	}


	/**
	 * Counts phones in a Sphinx4 grammar. Empty nodes are not accounted for.
	 */
	public static int countPhones(GrammarNode initialNode) {
		return countUnseenPhones(initialNode, new HashSet<GrammarNode>());
	}


	/**
	 * Builds up the vector by traversing the grammar graph recursively.
	 * @param node node of the graph to visit
	 * @param parent parent node
	 * @param parentId ID of the last (third) HMMState (within the vector)
	 *                 generated by the parent node
	 * @param index index at which to insert new states in the vector
	 * @param visited map of visited nodes to their 3rd HMM state in the vector
	 * @param acMod acoustic model (to look up HMMs)
	 * @param unitMgr unit manager (to look up HMMs)
	 * @return updated index at which to insert new states in the vector
	 */
	private int traversePhoneGraph(
			GrammarNode node,
			GrammarNode parent,
			int parentId,
			int index,
			Map<GrammarNode, Integer> visited,
			AcousticModel acMod,
			UnitManager unitMgr)
	{
		// ID of the last (third) HMM state in the phone
		Integer stateId = visited.get(node);

		// Is this a new discovery, or has the node been visited before?
		// Note that empty nodes are never "visited", because they do not exist
		// in our graph, so they aren't assigned any actual states.
		boolean newNode = stateId == null;

		if (!node.isEmpty()) {
			// Insert state triplet in vector if newly discovered and non-empty
			if (newNode) {
				insertStateTriplet(index, node, acMod, unitMgr);
				index += 3;
				stateId = index - 1;
				// Only mark nodes as "visited" if non-empty! (see above)
				visited.put(node, stateId);
			}

			// Link 1st state to parent's 3rd state, whether the node has been
			// visited before or not. (A node cannot be visited twice from the
			// same parent, but it can be visited by multiple parents, so we
			// need to create links for every parent.)
			if (parentId >= 0) {
				succ[parentId][nTrans[parentId]++] = stateId - 2;
				System.out.println(String.format(
						"traverse: new link: %s>%s", parent, node));
			}
		}

		// Keep traversing the graph if we haven't visited this phone before.
		if (newNode) {
			GrammarNode grandParent = parent;
			if (!node.isEmpty()) {
				parentId = stateId;
				parent = node;
			}

			for (GrammarArc arc: node.getSuccessors()) {
				GrammarNode sucNode = arc.getGrammarNode();
				System.out.println(String.format(
						"traverse: (%s) %s>%s", grandParent, node, sucNode));
				index = traversePhoneGraph(
						sucNode, parent, parentId, index, visited, acMod, unitMgr);
			}

			// Now that all transitions have been set by the recursive calls,
			// we can correct the inter-phone transition probabilities
			if (!node.isEmpty())
				setUniformInterPhoneTransitionProbabilities(stateId);
		}

		return index;
	}


	/**
	 * Inserts three emitting HMM states corresponding to the phone in the given
	 * node. The last state is left with no other successor than itself.
	 */
	private void insertStateTriplet(
			int index,
			GrammarNode node,
			AcousticModel acMod,
			UnitManager unitMgr)
	{
		String w = node.getWord().getSpelling();

		// word boundary hack
		if (w.startsWith("XZ"))
			w = w.substring(1+w.indexOf('Y'));

		// find HMM for this phone
		HMM hmm = acMod.lookupNearestHMM(
				unitMgr.getUnit(w), HMMPosition.UNDEFINED, false);

		// add phone states
		for (int i = 0; i < 3; i++) {
			int j = index + i;
			HMMState state = hmm.getState(i);

			assert state.isEmitting();
			assert !state.isExitState();
			assert state.getSuccessors().length == 2;

			states[j] = state;
			succ[j][0] = j;
			if (i < 2) {
				succ[j][1] = j+1;
				nTrans[j] = 2;
			} else {
				nTrans[j] = 1;
			}

			for (HMMStateArc arc: state.getSuccessors()) {
				HMMState arcState = arc.getHMMState();
				if (i == 2 && arcState.isExitState())
					continue;

				float p = arc.getLogProbability();
				if (arcState == state) {
					prob[j][0] = p;
				} else {
					assert i != 2;
					assert !arcState.isExitState();
					assert arcState == hmm.getState(i+1);
					prob[j][1] = p;
				}
			}
		}
	}


	/**
	 * Sets uniform inter-phone probabilities on the last state of an HMM.
	 * @param stateId ID of the last (3rd) state of an HMM
	 */
	private void setUniformInterPhoneTransitionProbabilities(int stateId) {
		assert stateId % 3 == 2 : "must be a third state";

		if (nTrans[stateId] < 2)
			return;

		assert prob[stateId][0] != 0f : "loop probability can't be 0";
		assert prob[stateId][1] == 0f : "non-loop probabilities must be 0";

		LogMath lm = HMMModels.getLogMath();
		double linearLoopProb = lm.logToLinear(prob[stateId][0]);
		float p = lm.linearToLog(
				(1f - linearLoopProb) / (double)(nTrans[stateId] - 1));

		for (byte j = 1; j < nTrans[stateId]; j++)
			prob[stateId][j] = p;
	}


	/**
	 * Constructs a grammar vector from an initial grammar node.
	 * @param node initial node of a Sphinx4 Grammar
	 * @see edu.cmu.sphinx.linguist.language.grammar
	 */
	public GrammarVector(GrammarNode node, AcousticModel acMod, UnitManager unitMgr) {
		nPhones = countPhones(node);
		nStates = 3 * nPhones;

		states = new HMMState[nStates];
		nTrans = new byte    [nStates];
		succ   = new int     [nStates][MAX_TRANSITIONS];
		prob   = new float   [nStates][MAX_TRANSITIONS];

		traversePhoneGraph(
				node,
				null,
				-1,
				0,
				new HashMap<GrammarNode, Integer>(),
				acMod,
				unitMgr);
	}


	/**
	 * Creates a Sphinx4 grammar from a piece of text.
	 * @param text words separated by spaces
	 * @return initial node
	 */
	public static GrammarNode createGrammarGraph(String text)
			throws MalformedURLException, ClassNotFoundException
	{
		PhoneticForcedGrammar g = new PhoneticForcedGrammar();
		g.setWords(Arrays.asList(text.split(" ")), new StdoutProgressDisplay());
		g.getInitialNode().dumpDot("grammar_graph.dot");
		return g.getInitialNode();
	}


	/**
	 * Constructs a grammar vector from a piece of text.
	 * @param text words separated by spaces
	 */
	public GrammarVector(String text, AcousticModel acMod, UnitManager unitMgr)
			throws MalformedURLException, ClassNotFoundException
	{
		this(createGrammarGraph(text), acMod, unitMgr);
	}


	/**
	 * Dumps a GraphViz/DOT representation of the vector.
	 */
	public void dumpDot(Writer w) throws IOException {
		LogMath lm = HMMModels.getLogMath();

		w.write("digraph {");

		for (int i = 0; i < nStates; i++) {
			HMMState s = states[i];
			w.write(String.format("\nnode%d [ label=\"%s %d\" ]", i,
					s.getHMM().getBaseUnit().getName(), s.getState()));
			for (byte j = 0; j < nTrans[i]; j++) {
				w.write(String.format("\nnode%d -> node%d [ label=%f ]",
						i, succ[i][j], lm.logToLinear(prob[i][j])));
			}
		}

		w.write("\n}");
		w.flush();
	}


	/**
	 * @return an array containing the best state for each frame
	 */
	public int[] viterbi(S4mfccBuffer mfcc) {
		float[] pv         = new float[nStates]; // previous vector
		float[] cv         = new float[nStates]; // current vector

		// Emission probability (frame score)
		float[] pEmission  = new float[nStates];

		// Probability to reach a state given the previous vector
		// max(pTransition(parent->s) * pv[s]) for each parent of state 's'
		float[] pReachMax  = new float[nStates];

		// State that yielded pReachMax for each state
		int  [] bestParent = new int  [nStates];

		Deque<int[]> backtrack = new ArrayDeque<int[]>();

		//----------------------------------------------------------------------

		// Initialize vector
		// We only have one initial state (state #0), probability 1
		// Probabilities are in the log domain
		Arrays.fill(cv, Float.NEGATIVE_INFINITY);
		cv[0] = 0;

		for (int f = 0; !mfcc.noMoreFramesAvailable; f++) {
			Data frame = mfcc.getData();
			if (frame instanceof DataStartSignal || frame instanceof DataEndSignal)
				continue;

			// Score frame according to each state in the vector
			System.out.println("Scoring Frame: " + f);
			for (int i = 0; i < nStates; i++)
				pEmission[i] = states[i].getScore(frame);

			// TODO these fills may not be very efficient
			Arrays.fill(pReachMax, Float.NEGATIVE_INFINITY);
			Arrays.fill(bestParent, -1);

			for (int parent = 0; parent < nStates; parent++) {
				// TODO: skip if pv[parent] is negative infinity?
				for (byte snt = 0; snt < nTrans[parent]; snt++) {
					int s = succ[parent][snt];
					float pReach = prob[parent][snt] + pv[parent]; // log domain
					if (pReach > pReachMax[s]) {
						pReachMax[s] = pReach;
						bestParent[s] = parent;
					}
				}
			}

			for (int s = 0; s < nStates; s++) {
				cv[s] = pEmission[s] + pReachMax[s]; // log domain
			}

			float[] recycled = pv;
			pv = cv;
			cv = recycled; // Avoid creating new arrays, recycle old pv as cv

			int[] bestParentCopy = new int[nStates];
			System.arraycopy(bestParent, 0, bestParentCopy, 0, nStates);
			backtrack.add(bestParentCopy);
		}

		for (int s = 0; s < nStates; s++) {
			System.out.println("CV[" + s + "] " + cv[s]);
		}

		System.out.println("Backtracking...");
		System.out.println(String.format(
				"Appx. footprint of backtrack stack: %dKB",
				backtrack.size() * (8+4+nStates*4) / 1024));
		System.out.println(Integer.SIZE);

		int pathLead = nStates-1;
		int[] timeline = new int[backtrack.size()];
		while (!backtrack.isEmpty()) {
			pathLead = backtrack.pop()[pathLead];
			timeline[backtrack.size()] = pathLead;
		}

		System.out.println("Note: only initial states are shown below");
		System.out.println("    TIME   STATE#     UNIT");
		for (int i = 0; i < timeline.length; i++) {
			if (i == 0 || timeline[i-1]/3 != timeline[i]/3) {
				System.out.println(String.format("%8.2f %8d %8s",
						TimeConverter.frame2sec(i),
						timeline[i],
						states[timeline[i]].getHMM().getBaseUnit()));
			}
		}

		return timeline;
	}


	public static void main(String[] args) throws Exception {
		if (args.length != 2) {
			System.out.println("USAGE: GrammarVector <SOUNDFILE.WAV> <\"transcription\">");
			System.exit(1);
		}

		final String wavpath = args[0];
		final String words   = args[1];

		System.out.println("PHONE COUNT: " + countPhones(createGrammarGraph(words)));

		ConfigurationManager cm = new ConfigurationManager("sr.cfg");
		UnitManager unitmgr = (UnitManager)cm.lookup("unitManager");
		assert unitmgr != null;

		TiedStateAcousticModel acmod = (TiedStateAcousticModel) HMMModels.getAcousticModels();

		GrammarVector gv = new GrammarVector(words, acmod, unitmgr);
		System.out.println("GRAPH SIZE: " + gv.nStates);
		gv.dumpDot(new FileWriter("grammar_vector.dot"));

		AudioFileDataSource afds = (AudioFileDataSource)cm.lookup("audioFileDataSource");
		afds.setAudioFile(new File(wavpath), null);
		S4mfccBuffer mfcc = new S4mfccBuffer();
		mfcc.setSource(S4ForceAlignBlocViterbi.getFrontEnd(afds));

		System.out.println("Starting Viterbi...");
		gv.viterbi(mfcc);
		System.out.println("done");
	}

}
